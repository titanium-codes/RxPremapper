package codes.titanium.premapper;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.WildcardType;

class ReflectionUtils {

  /**
   * Gets first method that is not generated by java for specified name
   */
  static Method getFirstNonSyntheticMethodForName(Object instance, String name) {
    if (instance.getClass().isSynthetic())
      throw new IllegalStateException("Do not use preprocessors as lambdas because of type erasure");
    for (Method method : instance.getClass().getMethods()) {
      if (method.getName().equals(name) && !method.isBridge())
        return method;
    }
    throw new NullPointerException("Not found non synthetic method for name " + name);
  }

  static boolean containsAnnotation(Annotation[] annotations, Class targetAnnotation) {
    for (Annotation annotation : annotations) {
      if (annotation.annotationType().equals(targetAnnotation))
        return true;
    }
    return false;
  }

  /**
   * Defines if one type can be assigned to another
   * Works in context of retrofit, so it is not covering some cases (Generic types, Wildcards for retrofit)
   *
   * @param fromType type want to test
   * @param toType   type that is used as a reference for testing
   */
  static boolean isAssignableFromTo(Type fromType, Type toType) {
    if (toType instanceof Class && fromType instanceof Class)
      return fromType.equals(toType);
    if (toType instanceof ParameterizedType) {
      ParameterizedType to = (ParameterizedType) toType;
      //from == Observable<String>
      if (fromType instanceof ParameterizedType) {
        ParameterizedType from = (ParameterizedType) fromType;
        return from.getRawType().equals(to.getRawType()) &&
            from.getActualTypeArguments().length == to.getActualTypeArguments().length &&
            all(from.getActualTypeArguments().length, i -> isAssignableFromTo(from.getActualTypeArguments()[i], to.getActualTypeArguments()[i]));
        // from == Observable
      }
      return to.getRawType().equals(fromType) &&
          all(to.getActualTypeArguments().length,
              i -> isAssignableFromTo(Object.class, to.getActualTypeArguments()[i]));

    }
    if (toType instanceof WildcardType) {
      WildcardType to = (WildcardType) toType;
      Type bounds = to.getUpperBounds()[0];
      //to == ? extends Set
      if (bounds instanceof Class) {
        Class<?> classBounds = (Class<?>) bounds;
        if (fromType instanceof Class)
          return classBounds.isAssignableFrom((Class<?>) fromType);
        return classBounds.isAssignableFrom((Class<?>) ((ParameterizedType) fromType).getRawType());
        //to == ? extends Set<String>
      } else {
        ParameterizedType toParametrized = (ParameterizedType) bounds;
        Class<?> parametrizedToRawType = (Class<?>) toParametrized.getRawType();
        //from == HashSet
        if (fromType instanceof Class)
          return parametrizedToRawType.isAssignableFrom((Class<?>) fromType);
        //from == HashSet<Number>
        ParameterizedType from = (ParameterizedType) fromType;
        Class<?> parametrizedFromRawType = (Class<?>) from.getRawType();
        return toParametrized.getActualTypeArguments().length == from.getActualTypeArguments().length &&
            parametrizedToRawType.isAssignableFrom(parametrizedFromRawType) &&
            all(from.getActualTypeArguments().length,
                i -> isAssignableFromTo(from.getActualTypeArguments()[i], toParametrized.getActualTypeArguments()[i]));
      }
    }
    //never reached
    return false;
  }

  /**
   * Helper method for iteration and checking indexes until length
   * As this library can be used in android, functional interfaces and stream api is not used
   */
  private static boolean all(int length, Predicate<Integer> predicate) {
    for (int i = 0; i < length; i++) {
      if (!predicate.test(i))
        return false;
    }
    return true;
  }

  /**
   * As this library can be used in android, functional interfaces and stream api is not used
   */
  private interface Predicate<T> {
    boolean test(T t);
  }

}
